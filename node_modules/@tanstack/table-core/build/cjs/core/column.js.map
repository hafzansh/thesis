{"version":3,"file":"column.js","sources":["../../../src/core/column.ts"],"sourcesContent":["import {\n  Column,\n  Table,\n  AccessorFn,\n  ColumnDef,\n  ColumnDefTemplate,\n  RowData,\n  ColumnMeta,\n} from '../types'\nimport { memo, UnionToIntersection } from '../utils'\nimport { CoreCell } from './cell'\nimport { CoreHeader } from './headers'\n\nexport type CoreColumnDefType = 'data' | 'display' | 'group'\n\ntype CoreColumnDefBase<TData extends RowData, TValue> = {\n  columns?: ColumnDef<TData>[]\n  header?: ColumnDefTemplate<\n    ReturnType<CoreHeader<TData, TValue>['getContext']>\n  >\n  footer?: ColumnDefTemplate<\n    ReturnType<CoreHeader<TData, TValue>['getContext']>\n  >\n  cell?: ColumnDefTemplate<ReturnType<CoreCell<TData, TValue>['getContext']>>\n  meta?: ColumnMeta\n}\n\ntype CoreColumnDefDisplay<TData extends RowData, TValue> = CoreColumnDefBase<\n  TData,\n  TValue\n> & {\n  id: string\n}\n\ntype CoreColumnDefDisplayWithStringHeader<\n  TData extends RowData,\n  TValue\n> = CoreColumnDefBase<TData, TValue> & {\n  header: string\n  id?: string\n}\n\ntype CoreColumnDefAccessorFn<\n  TData extends RowData,\n  TValue = unknown\n> = CoreColumnDefBase<TData, TValue> & {\n  accessorFn: AccessorFn<TData, TValue>\n  id: string\n  // accessorKey?: never\n}\n\ntype CoreColumnDefAccessorKey<\n  TData extends RowData,\n  TValue\n> = CoreColumnDefBase<TData, TValue> & {\n  accessorKey: keyof TData\n  id?: string\n  // accessorFn?: never\n}\n\nexport type CoreColumnDef<TData extends RowData, TValue> =\n  | CoreColumnDefDisplay<TData, TValue>\n  | CoreColumnDefDisplayWithStringHeader<TData, TValue>\n  | CoreColumnDefAccessorFn<TData>\n  | CoreColumnDefAccessorKey<TData, TValue>\n\nexport type CoreColumnDefResolved<\n  TData extends RowData,\n  TValue = unknown\n> = Partial<UnionToIntersection<CoreColumnDef<TData, TValue>>>\n\nexport type CoreColumn<TData extends RowData, TValue> = {\n  id: string\n  depth: number\n  accessorFn?: AccessorFn<TData, TValue>\n  columnDef: ColumnDef<TData>\n  columns: Column<TData, TValue>[]\n  parent?: Column<TData, TValue>\n  getFlatColumns: () => Column<TData, TValue>[]\n  getLeafColumns: () => Column<TData, TValue>[]\n}\n\nexport function createColumn<TData extends RowData, TValue>(\n  table: Table<TData>,\n  columnDef: ColumnDef<TData>,\n  depth: number,\n  parent?: Column<TData, TValue>\n) {\n  const defaultColumn = table._getDefaultColumnDef()\n\n  const resolvedColumnDef = {\n    ...defaultColumn,\n    ...columnDef,\n  } as CoreColumnDefResolved<TData>\n\n  let id =\n    resolvedColumnDef.id ??\n    resolvedColumnDef.accessorKey ??\n    (typeof resolvedColumnDef.header === 'string'\n      ? resolvedColumnDef.header\n      : undefined)\n\n  let accessorFn: AccessorFn<TData> | undefined\n\n  if (resolvedColumnDef.accessorFn) {\n    accessorFn = resolvedColumnDef.accessorFn\n  } else if (resolvedColumnDef.accessorKey) {\n    accessorFn = (originalRow: TData) =>\n      (originalRow as any)[resolvedColumnDef.accessorKey]\n  }\n\n  if (!id) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        resolvedColumnDef.accessorFn\n          ? `Columns require an id when using an accessorFn`\n          : `Columns require an id when using a non-string header`\n      )\n    }\n    throw new Error()\n  }\n\n  let column: CoreColumn<TData, any> = {\n    id: `${String(id)}`,\n    accessorFn,\n    parent: parent as any,\n    depth,\n    columnDef: resolvedColumnDef as ColumnDef<TData>,\n    columns: [],\n    getFlatColumns: memo(\n      () => [true],\n      () => {\n        return [\n          column as Column<TData, TValue>,\n          ...column.columns?.flatMap(d => d.getFlatColumns()),\n        ]\n      },\n      {\n        key: process.env.NODE_ENV === 'production' && 'column.getFlatColumns',\n        debug: () => table.options.debugAll ?? table.options.debugColumns,\n      }\n    ),\n    getLeafColumns: memo(\n      () => [table._getOrderColumnsFn()],\n      orderColumns => {\n        if (column.columns?.length) {\n          let leafColumns = column.columns.flatMap(column =>\n            column.getLeafColumns()\n          )\n\n          return orderColumns(leafColumns)\n        }\n\n        return [column as Column<TData, TValue>]\n      },\n      {\n        key: process.env.NODE_ENV === 'production' && 'column.getLeafColumns',\n        debug: () => table.options.debugAll ?? table.options.debugColumns,\n      }\n    ),\n  }\n\n  column = table._features.reduce((obj, feature) => {\n    return Object.assign(obj, feature.createColumn?.(column, table))\n  }, column)\n\n  // Yes, we have to convert table to uknown, because we know more than the compiler here.\n  return column as Column<TData, TValue>\n}\n"],"names":["createColumn","table","columnDef","depth","parent","defaultColumn","_getDefaultColumnDef","resolvedColumnDef","id","accessorKey","header","undefined","accessorFn","originalRow","process","env","NODE_ENV","Error","column","String","columns","getFlatColumns","memo","flatMap","d","key","debug","options","debugAll","debugColumns","getLeafColumns","_getOrderColumnsFn","orderColumns","length","leafColumns","_features","reduce","obj","feature","Object","assign"],"mappings":"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"}
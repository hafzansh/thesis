import { SvelteComponent, init, safe_not_equal, assign, element, set_attributes, insert, get_spread_update, noop, detach, exclude_internal_props, binding_callbacks, create_component, mount_component, get_spread_object, transition_in, transition_out, destroy_component } from 'svelte/internal';
import { Chart, LineController, RadarController, DoughnutController, PieController, BarController, PolarAreaController, BubbleController, ScatterController } from 'chart.js';
import { onMount, afterUpdate, onDestroy } from 'svelte';

function create_fragment$8(ctx) {
    let canvas;
    let canvas_levels = [
        /*props*/ ctx[1]
    ];
    let canvas_data = {};
    for(let i = 0; i < canvas_levels.length; i += 1){
        canvas_data = assign(canvas_data, canvas_levels[i]);
    }
    return {
        c () {
            canvas = element("canvas");
            set_attributes(canvas, canvas_data);
        },
        m (target, anchor) {
            insert(target, canvas, anchor);
            /*canvas_binding*/ ctx[6](canvas);
        },
        p (ctx, param) {
            set_attributes(canvas, canvas_data = get_spread_update(canvas_levels, [
                /*props*/ ctx[1]
            ]));
        },
        i: noop,
        o: noop,
        d (detaching) {
            if (detaching) detach(canvas);
            /*canvas_binding*/ ctx[6](null);
        }
    };
}
function clean(props) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    let { data , type , options , plugins , children , $$scope , $$slots , ...rest } = props;
    return rest;
}
function instance$8($$self, $$props, $$invalidate) {
    let { data ={
        labels: [],
        datasets: [
            {
                data: []
            }
        ]
    }  } = $$props;
    let { type ="line"  } = $$props;
    let { options ={}  } = $$props;
    let { plugins =[]  } = $$props;
    let props = clean($$props);
    let chart = null;
    let chartRef;
    onMount(()=>{
        chart = new Chart(chartRef, {
            type,
            data,
            options,
            plugins
        });
    });
    afterUpdate(()=>{
        if (!chart) return;
        chart.data = data;
        chart.options = options;
        chart.update();
    });
    onDestroy(()=>{
        if (chart) chart.destroy();
        chart = null;
    });
    function canvas_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](()=>{
            chartRef = $$value;
            $$invalidate(0, chartRef);
        });
    }
    $$self.$$set = ($$new_props)=>{
        $$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
        if ("data" in $$new_props) $$invalidate(2, data = $$new_props.data);
        if ("type" in $$new_props) $$invalidate(3, type = $$new_props.type);
        if ("options" in $$new_props) $$invalidate(4, options = $$new_props.options);
        if ("plugins" in $$new_props) $$invalidate(5, plugins = $$new_props.plugins);
    };
    $$props = exclude_internal_props($$props);
    return [
        chartRef,
        props,
        data,
        type,
        options,
        plugins,
        canvas_binding
    ];
}
class Base extends SvelteComponent {
    constructor(options){
        super();
        init(this, options, instance$8, create_fragment$8, safe_not_equal, {
            data: 2,
            type: 3,
            options: 4,
            plugins: 5
        });
    }
}

function create_fragment$7(ctx) {
    let base;
    let current;
    const base_spread_levels = [
        /*$$props*/ ctx[0],
        {
            type: "line"
        }
    ];
    let base_props = {};
    for(let i = 0; i < base_spread_levels.length; i += 1){
        base_props = assign(base_props, base_spread_levels[i]);
    }
    base = new Base({
        props: base_props
    });
    return {
        c () {
            create_component(base.$$.fragment);
        },
        m (target, anchor) {
            mount_component(base, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const base_changes = dirty & /*$$props*/ 1 ? get_spread_update(base_spread_levels, [
                get_spread_object(/*$$props*/ ctx[0]),
                base_spread_levels[1]
            ]) : {};
            base.$set(base_changes);
        },
        i (local) {
            if (current) return;
            transition_in(base.$$.fragment, local);
            current = true;
        },
        o (local) {
            transition_out(base.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            destroy_component(base, detaching);
        }
    };
}
function instance$7($$self, $$props, $$invalidate) {
    Chart.register(LineController);
    $$self.$$set = ($$new_props)=>{
        $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    };
    $$props = exclude_internal_props($$props);
    return [
        $$props
    ];
}
class Line extends SvelteComponent {
    constructor(options){
        super();
        init(this, options, instance$7, create_fragment$7, safe_not_equal, {});
    }
}

function create_fragment$6(ctx) {
    let base;
    let current;
    const base_spread_levels = [
        /*$$props*/ ctx[0],
        {
            type: "radar"
        }
    ];
    let base_props = {};
    for(let i = 0; i < base_spread_levels.length; i += 1){
        base_props = assign(base_props, base_spread_levels[i]);
    }
    base = new Base({
        props: base_props
    });
    return {
        c () {
            create_component(base.$$.fragment);
        },
        m (target, anchor) {
            mount_component(base, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const base_changes = dirty & /*$$props*/ 1 ? get_spread_update(base_spread_levels, [
                get_spread_object(/*$$props*/ ctx[0]),
                base_spread_levels[1]
            ]) : {};
            base.$set(base_changes);
        },
        i (local) {
            if (current) return;
            transition_in(base.$$.fragment, local);
            current = true;
        },
        o (local) {
            transition_out(base.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            destroy_component(base, detaching);
        }
    };
}
function instance$6($$self, $$props, $$invalidate) {
    Chart.register(RadarController);
    $$self.$$set = ($$new_props)=>{
        $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    };
    $$props = exclude_internal_props($$props);
    return [
        $$props
    ];
}
class Radar extends SvelteComponent {
    constructor(options){
        super();
        init(this, options, instance$6, create_fragment$6, safe_not_equal, {});
    }
}

function create_fragment$5(ctx) {
    let base;
    let current;
    const base_spread_levels = [
        /*$$props*/ ctx[0],
        {
            type: "doughnut"
        }
    ];
    let base_props = {};
    for(let i = 0; i < base_spread_levels.length; i += 1){
        base_props = assign(base_props, base_spread_levels[i]);
    }
    base = new Base({
        props: base_props
    });
    return {
        c () {
            create_component(base.$$.fragment);
        },
        m (target, anchor) {
            mount_component(base, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const base_changes = dirty & /*$$props*/ 1 ? get_spread_update(base_spread_levels, [
                get_spread_object(/*$$props*/ ctx[0]),
                base_spread_levels[1]
            ]) : {};
            base.$set(base_changes);
        },
        i (local) {
            if (current) return;
            transition_in(base.$$.fragment, local);
            current = true;
        },
        o (local) {
            transition_out(base.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            destroy_component(base, detaching);
        }
    };
}
function instance$5($$self, $$props, $$invalidate) {
    Chart.register(DoughnutController);
    $$self.$$set = ($$new_props)=>{
        $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    };
    $$props = exclude_internal_props($$props);
    return [
        $$props
    ];
}
class Doughnut extends SvelteComponent {
    constructor(options){
        super();
        init(this, options, instance$5, create_fragment$5, safe_not_equal, {});
    }
}

function create_fragment$4(ctx) {
    let base;
    let current;
    const base_spread_levels = [
        /*$$props*/ ctx[0],
        {
            type: "pie"
        }
    ];
    let base_props = {};
    for(let i = 0; i < base_spread_levels.length; i += 1){
        base_props = assign(base_props, base_spread_levels[i]);
    }
    base = new Base({
        props: base_props
    });
    return {
        c () {
            create_component(base.$$.fragment);
        },
        m (target, anchor) {
            mount_component(base, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const base_changes = dirty & /*$$props*/ 1 ? get_spread_update(base_spread_levels, [
                get_spread_object(/*$$props*/ ctx[0]),
                base_spread_levels[1]
            ]) : {};
            base.$set(base_changes);
        },
        i (local) {
            if (current) return;
            transition_in(base.$$.fragment, local);
            current = true;
        },
        o (local) {
            transition_out(base.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            destroy_component(base, detaching);
        }
    };
}
function instance$4($$self, $$props, $$invalidate) {
    Chart.register(PieController);
    $$self.$$set = ($$new_props)=>{
        $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    };
    $$props = exclude_internal_props($$props);
    return [
        $$props
    ];
}
class Pie extends SvelteComponent {
    constructor(options){
        super();
        init(this, options, instance$4, create_fragment$4, safe_not_equal, {});
    }
}

function create_fragment$3(ctx) {
    let base;
    let current;
    const base_spread_levels = [
        /*$$props*/ ctx[0],
        {
            type: "bar"
        }
    ];
    let base_props = {};
    for(let i = 0; i < base_spread_levels.length; i += 1){
        base_props = assign(base_props, base_spread_levels[i]);
    }
    base = new Base({
        props: base_props
    });
    return {
        c () {
            create_component(base.$$.fragment);
        },
        m (target, anchor) {
            mount_component(base, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const base_changes = dirty & /*$$props*/ 1 ? get_spread_update(base_spread_levels, [
                get_spread_object(/*$$props*/ ctx[0]),
                base_spread_levels[1]
            ]) : {};
            base.$set(base_changes);
        },
        i (local) {
            if (current) return;
            transition_in(base.$$.fragment, local);
            current = true;
        },
        o (local) {
            transition_out(base.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            destroy_component(base, detaching);
        }
    };
}
function instance$3($$self, $$props, $$invalidate) {
    Chart.register(BarController);
    $$self.$$set = ($$new_props)=>{
        $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    };
    $$props = exclude_internal_props($$props);
    return [
        $$props
    ];
}
class Bar extends SvelteComponent {
    constructor(options){
        super();
        init(this, options, instance$3, create_fragment$3, safe_not_equal, {});
    }
}

function create_fragment$2(ctx) {
    let base;
    let current;
    const base_spread_levels = [
        /*$$props*/ ctx[0],
        {
            type: "polarArea"
        }
    ];
    let base_props = {};
    for(let i = 0; i < base_spread_levels.length; i += 1){
        base_props = assign(base_props, base_spread_levels[i]);
    }
    base = new Base({
        props: base_props
    });
    return {
        c () {
            create_component(base.$$.fragment);
        },
        m (target, anchor) {
            mount_component(base, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const base_changes = dirty & /*$$props*/ 1 ? get_spread_update(base_spread_levels, [
                get_spread_object(/*$$props*/ ctx[0]),
                base_spread_levels[1]
            ]) : {};
            base.$set(base_changes);
        },
        i (local) {
            if (current) return;
            transition_in(base.$$.fragment, local);
            current = true;
        },
        o (local) {
            transition_out(base.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            destroy_component(base, detaching);
        }
    };
}
function instance$2($$self, $$props, $$invalidate) {
    Chart.register(PolarAreaController);
    $$self.$$set = ($$new_props)=>{
        $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    };
    $$props = exclude_internal_props($$props);
    return [
        $$props
    ];
}
class Polar extends SvelteComponent {
    constructor(options){
        super();
        init(this, options, instance$2, create_fragment$2, safe_not_equal, {});
    }
}

function create_fragment$1(ctx) {
    let base;
    let current;
    const base_spread_levels = [
        /*$$props*/ ctx[0],
        {
            type: "bubble"
        }
    ];
    let base_props = {};
    for(let i = 0; i < base_spread_levels.length; i += 1){
        base_props = assign(base_props, base_spread_levels[i]);
    }
    base = new Base({
        props: base_props
    });
    return {
        c () {
            create_component(base.$$.fragment);
        },
        m (target, anchor) {
            mount_component(base, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const base_changes = dirty & /*$$props*/ 1 ? get_spread_update(base_spread_levels, [
                get_spread_object(/*$$props*/ ctx[0]),
                base_spread_levels[1]
            ]) : {};
            base.$set(base_changes);
        },
        i (local) {
            if (current) return;
            transition_in(base.$$.fragment, local);
            current = true;
        },
        o (local) {
            transition_out(base.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            destroy_component(base, detaching);
        }
    };
}
function instance$1($$self, $$props, $$invalidate) {
    Chart.register(BubbleController);
    $$self.$$set = ($$new_props)=>{
        $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    };
    $$props = exclude_internal_props($$props);
    return [
        $$props
    ];
}
class Bubble extends SvelteComponent {
    constructor(options){
        super();
        init(this, options, instance$1, create_fragment$1, safe_not_equal, {});
    }
}

function create_fragment(ctx) {
    let base;
    let current;
    const base_spread_levels = [
        /*$$props*/ ctx[0],
        {
            type: "scatter"
        }
    ];
    let base_props = {};
    for(let i = 0; i < base_spread_levels.length; i += 1){
        base_props = assign(base_props, base_spread_levels[i]);
    }
    base = new Base({
        props: base_props
    });
    return {
        c () {
            create_component(base.$$.fragment);
        },
        m (target, anchor) {
            mount_component(base, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const base_changes = dirty & /*$$props*/ 1 ? get_spread_update(base_spread_levels, [
                get_spread_object(/*$$props*/ ctx[0]),
                base_spread_levels[1]
            ]) : {};
            base.$set(base_changes);
        },
        i (local) {
            if (current) return;
            transition_in(base.$$.fragment, local);
            current = true;
        },
        o (local) {
            transition_out(base.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            destroy_component(base, detaching);
        }
    };
}
function instance($$self, $$props, $$invalidate) {
    Chart.register(ScatterController);
    $$self.$$set = ($$new_props)=>{
        $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    };
    $$props = exclude_internal_props($$props);
    return [
        $$props
    ];
}
class Scatter extends SvelteComponent {
    constructor(options){
        super();
        init(this, options, instance, create_fragment, safe_not_equal, {});
    }
}

export { Bar, Base, Bubble, Doughnut, Line, Pie, Polar, Radar, Scatter };
//# sourceMappingURL=index.js.map

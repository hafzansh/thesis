'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var internal = require('svelte/internal');
var chart_js = require('chart.js');
var svelte = require('svelte');

function create_fragment$8(ctx) {
    let canvas;
    let canvas_levels = [
        /*props*/ ctx[1]
    ];
    let canvas_data = {};
    for(let i = 0; i < canvas_levels.length; i += 1){
        canvas_data = internal.assign(canvas_data, canvas_levels[i]);
    }
    return {
        c () {
            canvas = internal.element("canvas");
            internal.set_attributes(canvas, canvas_data);
        },
        m (target, anchor) {
            internal.insert(target, canvas, anchor);
            /*canvas_binding*/ ctx[6](canvas);
        },
        p (ctx, param) {
            internal.set_attributes(canvas, canvas_data = internal.get_spread_update(canvas_levels, [
                /*props*/ ctx[1]
            ]));
        },
        i: internal.noop,
        o: internal.noop,
        d (detaching) {
            if (detaching) internal.detach(canvas);
            /*canvas_binding*/ ctx[6](null);
        }
    };
}
function clean(props) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    let { data , type , options , plugins , children , $$scope , $$slots , ...rest } = props;
    return rest;
}
function instance$8($$self, $$props, $$invalidate) {
    let { data ={
        labels: [],
        datasets: [
            {
                data: []
            }
        ]
    }  } = $$props;
    let { type ="line"  } = $$props;
    let { options ={}  } = $$props;
    let { plugins =[]  } = $$props;
    let props = clean($$props);
    let chart = null;
    let chartRef;
    svelte.onMount(()=>{
        chart = new chart_js.Chart(chartRef, {
            type,
            data,
            options,
            plugins
        });
    });
    svelte.afterUpdate(()=>{
        if (!chart) return;
        chart.data = data;
        chart.options = options;
        chart.update();
    });
    svelte.onDestroy(()=>{
        if (chart) chart.destroy();
        chart = null;
    });
    function canvas_binding($$value) {
        internal.binding_callbacks[$$value ? "unshift" : "push"](()=>{
            chartRef = $$value;
            $$invalidate(0, chartRef);
        });
    }
    $$self.$$set = ($$new_props)=>{
        $$invalidate(8, $$props = internal.assign(internal.assign({}, $$props), internal.exclude_internal_props($$new_props)));
        if ("data" in $$new_props) $$invalidate(2, data = $$new_props.data);
        if ("type" in $$new_props) $$invalidate(3, type = $$new_props.type);
        if ("options" in $$new_props) $$invalidate(4, options = $$new_props.options);
        if ("plugins" in $$new_props) $$invalidate(5, plugins = $$new_props.plugins);
    };
    $$props = internal.exclude_internal_props($$props);
    return [
        chartRef,
        props,
        data,
        type,
        options,
        plugins,
        canvas_binding
    ];
}
class Base extends internal.SvelteComponent {
    constructor(options){
        super();
        internal.init(this, options, instance$8, create_fragment$8, internal.safe_not_equal, {
            data: 2,
            type: 3,
            options: 4,
            plugins: 5
        });
    }
}

function create_fragment$7(ctx) {
    let base;
    let current;
    const base_spread_levels = [
        /*$$props*/ ctx[0],
        {
            type: "line"
        }
    ];
    let base_props = {};
    for(let i = 0; i < base_spread_levels.length; i += 1){
        base_props = internal.assign(base_props, base_spread_levels[i]);
    }
    base = new Base({
        props: base_props
    });
    return {
        c () {
            internal.create_component(base.$$.fragment);
        },
        m (target, anchor) {
            internal.mount_component(base, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const base_changes = dirty & /*$$props*/ 1 ? internal.get_spread_update(base_spread_levels, [
                internal.get_spread_object(/*$$props*/ ctx[0]),
                base_spread_levels[1]
            ]) : {};
            base.$set(base_changes);
        },
        i (local) {
            if (current) return;
            internal.transition_in(base.$$.fragment, local);
            current = true;
        },
        o (local) {
            internal.transition_out(base.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            internal.destroy_component(base, detaching);
        }
    };
}
function instance$7($$self, $$props, $$invalidate) {
    chart_js.Chart.register(chart_js.LineController);
    $$self.$$set = ($$new_props)=>{
        $$invalidate(0, $$props = internal.assign(internal.assign({}, $$props), internal.exclude_internal_props($$new_props)));
    };
    $$props = internal.exclude_internal_props($$props);
    return [
        $$props
    ];
}
class Line extends internal.SvelteComponent {
    constructor(options){
        super();
        internal.init(this, options, instance$7, create_fragment$7, internal.safe_not_equal, {});
    }
}

function create_fragment$6(ctx) {
    let base;
    let current;
    const base_spread_levels = [
        /*$$props*/ ctx[0],
        {
            type: "radar"
        }
    ];
    let base_props = {};
    for(let i = 0; i < base_spread_levels.length; i += 1){
        base_props = internal.assign(base_props, base_spread_levels[i]);
    }
    base = new Base({
        props: base_props
    });
    return {
        c () {
            internal.create_component(base.$$.fragment);
        },
        m (target, anchor) {
            internal.mount_component(base, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const base_changes = dirty & /*$$props*/ 1 ? internal.get_spread_update(base_spread_levels, [
                internal.get_spread_object(/*$$props*/ ctx[0]),
                base_spread_levels[1]
            ]) : {};
            base.$set(base_changes);
        },
        i (local) {
            if (current) return;
            internal.transition_in(base.$$.fragment, local);
            current = true;
        },
        o (local) {
            internal.transition_out(base.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            internal.destroy_component(base, detaching);
        }
    };
}
function instance$6($$self, $$props, $$invalidate) {
    chart_js.Chart.register(chart_js.RadarController);
    $$self.$$set = ($$new_props)=>{
        $$invalidate(0, $$props = internal.assign(internal.assign({}, $$props), internal.exclude_internal_props($$new_props)));
    };
    $$props = internal.exclude_internal_props($$props);
    return [
        $$props
    ];
}
class Radar extends internal.SvelteComponent {
    constructor(options){
        super();
        internal.init(this, options, instance$6, create_fragment$6, internal.safe_not_equal, {});
    }
}

function create_fragment$5(ctx) {
    let base;
    let current;
    const base_spread_levels = [
        /*$$props*/ ctx[0],
        {
            type: "doughnut"
        }
    ];
    let base_props = {};
    for(let i = 0; i < base_spread_levels.length; i += 1){
        base_props = internal.assign(base_props, base_spread_levels[i]);
    }
    base = new Base({
        props: base_props
    });
    return {
        c () {
            internal.create_component(base.$$.fragment);
        },
        m (target, anchor) {
            internal.mount_component(base, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const base_changes = dirty & /*$$props*/ 1 ? internal.get_spread_update(base_spread_levels, [
                internal.get_spread_object(/*$$props*/ ctx[0]),
                base_spread_levels[1]
            ]) : {};
            base.$set(base_changes);
        },
        i (local) {
            if (current) return;
            internal.transition_in(base.$$.fragment, local);
            current = true;
        },
        o (local) {
            internal.transition_out(base.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            internal.destroy_component(base, detaching);
        }
    };
}
function instance$5($$self, $$props, $$invalidate) {
    chart_js.Chart.register(chart_js.DoughnutController);
    $$self.$$set = ($$new_props)=>{
        $$invalidate(0, $$props = internal.assign(internal.assign({}, $$props), internal.exclude_internal_props($$new_props)));
    };
    $$props = internal.exclude_internal_props($$props);
    return [
        $$props
    ];
}
class Doughnut extends internal.SvelteComponent {
    constructor(options){
        super();
        internal.init(this, options, instance$5, create_fragment$5, internal.safe_not_equal, {});
    }
}

function create_fragment$4(ctx) {
    let base;
    let current;
    const base_spread_levels = [
        /*$$props*/ ctx[0],
        {
            type: "pie"
        }
    ];
    let base_props = {};
    for(let i = 0; i < base_spread_levels.length; i += 1){
        base_props = internal.assign(base_props, base_spread_levels[i]);
    }
    base = new Base({
        props: base_props
    });
    return {
        c () {
            internal.create_component(base.$$.fragment);
        },
        m (target, anchor) {
            internal.mount_component(base, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const base_changes = dirty & /*$$props*/ 1 ? internal.get_spread_update(base_spread_levels, [
                internal.get_spread_object(/*$$props*/ ctx[0]),
                base_spread_levels[1]
            ]) : {};
            base.$set(base_changes);
        },
        i (local) {
            if (current) return;
            internal.transition_in(base.$$.fragment, local);
            current = true;
        },
        o (local) {
            internal.transition_out(base.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            internal.destroy_component(base, detaching);
        }
    };
}
function instance$4($$self, $$props, $$invalidate) {
    chart_js.Chart.register(chart_js.PieController);
    $$self.$$set = ($$new_props)=>{
        $$invalidate(0, $$props = internal.assign(internal.assign({}, $$props), internal.exclude_internal_props($$new_props)));
    };
    $$props = internal.exclude_internal_props($$props);
    return [
        $$props
    ];
}
class Pie extends internal.SvelteComponent {
    constructor(options){
        super();
        internal.init(this, options, instance$4, create_fragment$4, internal.safe_not_equal, {});
    }
}

function create_fragment$3(ctx) {
    let base;
    let current;
    const base_spread_levels = [
        /*$$props*/ ctx[0],
        {
            type: "bar"
        }
    ];
    let base_props = {};
    for(let i = 0; i < base_spread_levels.length; i += 1){
        base_props = internal.assign(base_props, base_spread_levels[i]);
    }
    base = new Base({
        props: base_props
    });
    return {
        c () {
            internal.create_component(base.$$.fragment);
        },
        m (target, anchor) {
            internal.mount_component(base, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const base_changes = dirty & /*$$props*/ 1 ? internal.get_spread_update(base_spread_levels, [
                internal.get_spread_object(/*$$props*/ ctx[0]),
                base_spread_levels[1]
            ]) : {};
            base.$set(base_changes);
        },
        i (local) {
            if (current) return;
            internal.transition_in(base.$$.fragment, local);
            current = true;
        },
        o (local) {
            internal.transition_out(base.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            internal.destroy_component(base, detaching);
        }
    };
}
function instance$3($$self, $$props, $$invalidate) {
    chart_js.Chart.register(chart_js.BarController);
    $$self.$$set = ($$new_props)=>{
        $$invalidate(0, $$props = internal.assign(internal.assign({}, $$props), internal.exclude_internal_props($$new_props)));
    };
    $$props = internal.exclude_internal_props($$props);
    return [
        $$props
    ];
}
class Bar extends internal.SvelteComponent {
    constructor(options){
        super();
        internal.init(this, options, instance$3, create_fragment$3, internal.safe_not_equal, {});
    }
}

function create_fragment$2(ctx) {
    let base;
    let current;
    const base_spread_levels = [
        /*$$props*/ ctx[0],
        {
            type: "polarArea"
        }
    ];
    let base_props = {};
    for(let i = 0; i < base_spread_levels.length; i += 1){
        base_props = internal.assign(base_props, base_spread_levels[i]);
    }
    base = new Base({
        props: base_props
    });
    return {
        c () {
            internal.create_component(base.$$.fragment);
        },
        m (target, anchor) {
            internal.mount_component(base, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const base_changes = dirty & /*$$props*/ 1 ? internal.get_spread_update(base_spread_levels, [
                internal.get_spread_object(/*$$props*/ ctx[0]),
                base_spread_levels[1]
            ]) : {};
            base.$set(base_changes);
        },
        i (local) {
            if (current) return;
            internal.transition_in(base.$$.fragment, local);
            current = true;
        },
        o (local) {
            internal.transition_out(base.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            internal.destroy_component(base, detaching);
        }
    };
}
function instance$2($$self, $$props, $$invalidate) {
    chart_js.Chart.register(chart_js.PolarAreaController);
    $$self.$$set = ($$new_props)=>{
        $$invalidate(0, $$props = internal.assign(internal.assign({}, $$props), internal.exclude_internal_props($$new_props)));
    };
    $$props = internal.exclude_internal_props($$props);
    return [
        $$props
    ];
}
class Polar extends internal.SvelteComponent {
    constructor(options){
        super();
        internal.init(this, options, instance$2, create_fragment$2, internal.safe_not_equal, {});
    }
}

function create_fragment$1(ctx) {
    let base;
    let current;
    const base_spread_levels = [
        /*$$props*/ ctx[0],
        {
            type: "bubble"
        }
    ];
    let base_props = {};
    for(let i = 0; i < base_spread_levels.length; i += 1){
        base_props = internal.assign(base_props, base_spread_levels[i]);
    }
    base = new Base({
        props: base_props
    });
    return {
        c () {
            internal.create_component(base.$$.fragment);
        },
        m (target, anchor) {
            internal.mount_component(base, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const base_changes = dirty & /*$$props*/ 1 ? internal.get_spread_update(base_spread_levels, [
                internal.get_spread_object(/*$$props*/ ctx[0]),
                base_spread_levels[1]
            ]) : {};
            base.$set(base_changes);
        },
        i (local) {
            if (current) return;
            internal.transition_in(base.$$.fragment, local);
            current = true;
        },
        o (local) {
            internal.transition_out(base.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            internal.destroy_component(base, detaching);
        }
    };
}
function instance$1($$self, $$props, $$invalidate) {
    chart_js.Chart.register(chart_js.BubbleController);
    $$self.$$set = ($$new_props)=>{
        $$invalidate(0, $$props = internal.assign(internal.assign({}, $$props), internal.exclude_internal_props($$new_props)));
    };
    $$props = internal.exclude_internal_props($$props);
    return [
        $$props
    ];
}
class Bubble extends internal.SvelteComponent {
    constructor(options){
        super();
        internal.init(this, options, instance$1, create_fragment$1, internal.safe_not_equal, {});
    }
}

function create_fragment(ctx) {
    let base;
    let current;
    const base_spread_levels = [
        /*$$props*/ ctx[0],
        {
            type: "scatter"
        }
    ];
    let base_props = {};
    for(let i = 0; i < base_spread_levels.length; i += 1){
        base_props = internal.assign(base_props, base_spread_levels[i]);
    }
    base = new Base({
        props: base_props
    });
    return {
        c () {
            internal.create_component(base.$$.fragment);
        },
        m (target, anchor) {
            internal.mount_component(base, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const base_changes = dirty & /*$$props*/ 1 ? internal.get_spread_update(base_spread_levels, [
                internal.get_spread_object(/*$$props*/ ctx[0]),
                base_spread_levels[1]
            ]) : {};
            base.$set(base_changes);
        },
        i (local) {
            if (current) return;
            internal.transition_in(base.$$.fragment, local);
            current = true;
        },
        o (local) {
            internal.transition_out(base.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            internal.destroy_component(base, detaching);
        }
    };
}
function instance($$self, $$props, $$invalidate) {
    chart_js.Chart.register(chart_js.ScatterController);
    $$self.$$set = ($$new_props)=>{
        $$invalidate(0, $$props = internal.assign(internal.assign({}, $$props), internal.exclude_internal_props($$new_props)));
    };
    $$props = internal.exclude_internal_props($$props);
    return [
        $$props
    ];
}
class Scatter extends internal.SvelteComponent {
    constructor(options){
        super();
        internal.init(this, options, instance, create_fragment, internal.safe_not_equal, {});
    }
}

exports.Bar = Bar;
exports.Base = Base;
exports.Bubble = Bubble;
exports.Doughnut = Doughnut;
exports.Line = Line;
exports.Pie = Pie;
exports.Polar = Polar;
exports.Radar = Radar;
exports.Scatter = Scatter;
//# sourceMappingURL=index.cjs.map

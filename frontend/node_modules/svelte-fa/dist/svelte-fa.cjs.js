'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var internal = require('svelte/internal');

const parseNumber = parseFloat;

function joinCss(obj, separator = ';') {
  let texts;
  if (Array.isArray(obj)) {
    texts = obj.filter((text) => text);
  } else {
    texts = [];
    for (const prop in obj) {
      if (obj[prop]) {
        texts.push(`${prop}:${obj[prop]}`);
      }
    }
  }
  return texts.join(separator);
}

function getStyles(style, size, pull, fw) {
  let float;
  let width;
  const height = '1em';
  let lineHeight;
  let fontSize;
  let textAlign;
  let verticalAlign = '-.125em';
  const overflow = 'visible';

  if (fw) {
    textAlign = 'center';
    width = '1.25em';
  }

  if (pull) {
    float = pull;
  }

  if (size) {
    if (size == 'lg') {
      fontSize = '1.33333em';
      lineHeight = '.75em';
      verticalAlign = '-.225em';
    } else if (size == 'xs') {
      fontSize = '.75em';
    } else if (size == 'sm') {
      fontSize = '.875em';
    } else {
      fontSize = size.replace('x', 'em');
    }
  }

  return joinCss([
    joinCss({
      float,
      width,
      height,
      'line-height': lineHeight,
      'font-size': fontSize,
      'text-align': textAlign,
      'vertical-align': verticalAlign,
      'transform-origin': 'center',
      overflow,
    }),
    style,
  ]);
}

function getTransform(
  scale,
  translateX,
  translateY,
  rotate,
  flip,
  translateTimes = 1,
  translateUnit = '',
  rotateUnit = '',
) {
  let flipX = 1;
  let flipY = 1;

  if (flip) {
    if (flip == 'horizontal') {
      flipX = -1;
    } else if (flip == 'vertical') {
      flipY = -1;
    } else {
      flipX = flipY = -1;
    }
  }

  return joinCss(
    [
      `translate(${parseNumber(translateX) * translateTimes}${translateUnit},${parseNumber(translateY) * translateTimes}${translateUnit})`,
      `scale(${flipX * parseNumber(scale)},${flipY * parseNumber(scale)})`,
      rotate && `rotate(${rotate}${rotateUnit})`,
    ],
    ' ',
  );
}

/* src\fa.svelte generated by Svelte v3.16.7 */

function add_css$1() {
	var style = internal.element("style");
	style.id = "svelte-1cj2gr0-style";
	style.textContent = ".spin.svelte-1cj2gr0{animation:svelte-1cj2gr0-spin 2s 0s infinite linear}.pulse.svelte-1cj2gr0{animation:svelte-1cj2gr0-spin 1s infinite steps(8)}@keyframes svelte-1cj2gr0-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}";
	internal.append(document.head, style);
}

// (66:0) {#if i[4]}
function create_if_block(ctx) {
	let svg;
	let g1;
	let g0;
	let g1_transform_value;
	let g1_transform_origin_value;
	let svg_class_value;
	let svg_viewBox_value;

	function select_block_type(ctx, dirty) {
		if (typeof /*i*/ ctx[10][4] == "string") return create_if_block_1;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			svg = internal.svg_element("svg");
			g1 = internal.svg_element("g");
			g0 = internal.svg_element("g");
			if_block.c();
			internal.attr(g0, "transform", /*transform*/ ctx[12]);
			internal.attr(g1, "transform", g1_transform_value = "translate(" + /*i*/ ctx[10][0] / 2 + " " + /*i*/ ctx[10][1] / 2 + ")");
			internal.attr(g1, "transform-origin", g1_transform_origin_value = "" + (/*i*/ ctx[10][0] / 4 + " 0"));
			internal.attr(svg, "id", /*id*/ ctx[1]);
			internal.attr(svg, "class", svg_class_value = "svelte-fa " + /*clazz*/ ctx[0] + " svelte-1cj2gr0");
			internal.attr(svg, "style", /*s*/ ctx[11]);
			internal.attr(svg, "viewBox", svg_viewBox_value = "0 0 " + /*i*/ ctx[10][0] + " " + /*i*/ ctx[10][1]);
			internal.attr(svg, "aria-hidden", "true");
			internal.attr(svg, "role", "img");
			internal.attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			internal.toggle_class(svg, "pulse", /*pulse*/ ctx[4]);
			internal.toggle_class(svg, "spin", /*spin*/ ctx[3]);
		},
		m(target, anchor) {
			internal.insert(target, svg, anchor);
			internal.append(svg, g1);
			internal.append(g1, g0);
			if_block.m(g0, null);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(g0, null);
				}
			}

			if (dirty & /*transform*/ 4096) {
				internal.attr(g0, "transform", /*transform*/ ctx[12]);
			}

			if (dirty & /*i*/ 1024 && g1_transform_value !== (g1_transform_value = "translate(" + /*i*/ ctx[10][0] / 2 + " " + /*i*/ ctx[10][1] / 2 + ")")) {
				internal.attr(g1, "transform", g1_transform_value);
			}

			if (dirty & /*i*/ 1024 && g1_transform_origin_value !== (g1_transform_origin_value = "" + (/*i*/ ctx[10][0] / 4 + " 0"))) {
				internal.attr(g1, "transform-origin", g1_transform_origin_value);
			}

			if (dirty & /*id*/ 2) {
				internal.attr(svg, "id", /*id*/ ctx[1]);
			}

			if (dirty & /*clazz*/ 1 && svg_class_value !== (svg_class_value = "svelte-fa " + /*clazz*/ ctx[0] + " svelte-1cj2gr0")) {
				internal.attr(svg, "class", svg_class_value);
			}

			if (dirty & /*s*/ 2048) {
				internal.attr(svg, "style", /*s*/ ctx[11]);
			}

			if (dirty & /*i*/ 1024 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*i*/ ctx[10][0] + " " + /*i*/ ctx[10][1])) {
				internal.attr(svg, "viewBox", svg_viewBox_value);
			}

			if (dirty & /*clazz, pulse*/ 17) {
				internal.toggle_class(svg, "pulse", /*pulse*/ ctx[4]);
			}

			if (dirty & /*clazz, spin*/ 9) {
				internal.toggle_class(svg, "spin", /*spin*/ ctx[3]);
			}
		},
		d(detaching) {
			if (detaching) internal.detach(svg);
			if_block.d();
		}
	};
}

// (89:8) {:else}
function create_else_block(ctx) {
	let path0;
	let path0_d_value;
	let path0_fill_value;
	let path0_fill_opacity_value;
	let path0_transform_value;
	let path1;
	let path1_d_value;
	let path1_fill_value;
	let path1_fill_opacity_value;
	let path1_transform_value;

	return {
		c() {
			path0 = internal.svg_element("path");
			path1 = internal.svg_element("path");
			internal.attr(path0, "d", path0_d_value = /*i*/ ctx[10][4][0]);
			internal.attr(path0, "fill", path0_fill_value = /*secondaryColor*/ ctx[6] || /*color*/ ctx[2] || "currentColor");

			internal.attr(path0, "fill-opacity", path0_fill_opacity_value = /*swapOpacity*/ ctx[9] != false
			? /*primaryOpacity*/ ctx[7]
			: /*secondaryOpacity*/ ctx[8]);

			internal.attr(path0, "transform", path0_transform_value = "translate(" + /*i*/ ctx[10][0] / -2 + " " + /*i*/ ctx[10][1] / -2 + ")");
			internal.attr(path1, "d", path1_d_value = /*i*/ ctx[10][4][1]);
			internal.attr(path1, "fill", path1_fill_value = /*primaryColor*/ ctx[5] || /*color*/ ctx[2] || "currentColor");

			internal.attr(path1, "fill-opacity", path1_fill_opacity_value = /*swapOpacity*/ ctx[9] != false
			? /*secondaryOpacity*/ ctx[8]
			: /*primaryOpacity*/ ctx[7]);

			internal.attr(path1, "transform", path1_transform_value = "translate(" + /*i*/ ctx[10][0] / -2 + " " + /*i*/ ctx[10][1] / -2 + ")");
		},
		m(target, anchor) {
			internal.insert(target, path0, anchor);
			internal.insert(target, path1, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*i*/ 1024 && path0_d_value !== (path0_d_value = /*i*/ ctx[10][4][0])) {
				internal.attr(path0, "d", path0_d_value);
			}

			if (dirty & /*secondaryColor, color*/ 68 && path0_fill_value !== (path0_fill_value = /*secondaryColor*/ ctx[6] || /*color*/ ctx[2] || "currentColor")) {
				internal.attr(path0, "fill", path0_fill_value);
			}

			if (dirty & /*swapOpacity, primaryOpacity, secondaryOpacity*/ 896 && path0_fill_opacity_value !== (path0_fill_opacity_value = /*swapOpacity*/ ctx[9] != false
			? /*primaryOpacity*/ ctx[7]
			: /*secondaryOpacity*/ ctx[8])) {
				internal.attr(path0, "fill-opacity", path0_fill_opacity_value);
			}

			if (dirty & /*i*/ 1024 && path0_transform_value !== (path0_transform_value = "translate(" + /*i*/ ctx[10][0] / -2 + " " + /*i*/ ctx[10][1] / -2 + ")")) {
				internal.attr(path0, "transform", path0_transform_value);
			}

			if (dirty & /*i*/ 1024 && path1_d_value !== (path1_d_value = /*i*/ ctx[10][4][1])) {
				internal.attr(path1, "d", path1_d_value);
			}

			if (dirty & /*primaryColor, color*/ 36 && path1_fill_value !== (path1_fill_value = /*primaryColor*/ ctx[5] || /*color*/ ctx[2] || "currentColor")) {
				internal.attr(path1, "fill", path1_fill_value);
			}

			if (dirty & /*swapOpacity, secondaryOpacity, primaryOpacity*/ 896 && path1_fill_opacity_value !== (path1_fill_opacity_value = /*swapOpacity*/ ctx[9] != false
			? /*secondaryOpacity*/ ctx[8]
			: /*primaryOpacity*/ ctx[7])) {
				internal.attr(path1, "fill-opacity", path1_fill_opacity_value);
			}

			if (dirty & /*i*/ 1024 && path1_transform_value !== (path1_transform_value = "translate(" + /*i*/ ctx[10][0] / -2 + " " + /*i*/ ctx[10][1] / -2 + ")")) {
				internal.attr(path1, "transform", path1_transform_value);
			}
		},
		d(detaching) {
			if (detaching) internal.detach(path0);
			if (detaching) internal.detach(path1);
		}
	};
}

// (83:8) {#if typeof i[4] == 'string'}
function create_if_block_1(ctx) {
	let path;
	let path_d_value;
	let path_fill_value;
	let path_transform_value;

	return {
		c() {
			path = internal.svg_element("path");
			internal.attr(path, "d", path_d_value = /*i*/ ctx[10][4]);
			internal.attr(path, "fill", path_fill_value = /*color*/ ctx[2] || /*primaryColor*/ ctx[5] || "currentColor");
			internal.attr(path, "transform", path_transform_value = "translate(" + /*i*/ ctx[10][0] / -2 + " " + /*i*/ ctx[10][1] / -2 + ")");
		},
		m(target, anchor) {
			internal.insert(target, path, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*i*/ 1024 && path_d_value !== (path_d_value = /*i*/ ctx[10][4])) {
				internal.attr(path, "d", path_d_value);
			}

			if (dirty & /*color, primaryColor*/ 36 && path_fill_value !== (path_fill_value = /*color*/ ctx[2] || /*primaryColor*/ ctx[5] || "currentColor")) {
				internal.attr(path, "fill", path_fill_value);
			}

			if (dirty & /*i*/ 1024 && path_transform_value !== (path_transform_value = "translate(" + /*i*/ ctx[10][0] / -2 + " " + /*i*/ ctx[10][1] / -2 + ")")) {
				internal.attr(path, "transform", path_transform_value);
			}
		},
		d(detaching) {
			if (detaching) internal.detach(path);
		}
	};
}

function create_fragment$2(ctx) {
	let if_block_anchor;
	let if_block = /*i*/ ctx[10][4] && create_if_block(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = internal.empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			internal.insert(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (/*i*/ ctx[10][4]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: internal.noop,
		o: internal.noop,
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) internal.detach(if_block_anchor);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let { class: clazz = "" } = $$props;
	let { id = "" } = $$props;
	let { style = "" } = $$props;
	let { icon } = $$props;
	let { size = "" } = $$props;
	let { color = "" } = $$props;
	let { fw = false } = $$props;
	let { pull = "" } = $$props;
	let { scale = 1 } = $$props;
	let { translateX = 0 } = $$props;
	let { translateY = 0 } = $$props;
	let { rotate = "" } = $$props;
	let { flip = false } = $$props;
	let { spin = false } = $$props;
	let { pulse = false } = $$props;
	let { primaryColor = "" } = $$props;
	let { secondaryColor = "" } = $$props;
	let { primaryOpacity = 1 } = $$props;
	let { secondaryOpacity = 0.4 } = $$props;
	let { swapOpacity = false } = $$props;
	let i;
	let s;
	let transform;

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, clazz = $$props.class);
		if ("id" in $$props) $$invalidate(1, id = $$props.id);
		if ("style" in $$props) $$invalidate(13, style = $$props.style);
		if ("icon" in $$props) $$invalidate(14, icon = $$props.icon);
		if ("size" in $$props) $$invalidate(15, size = $$props.size);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("fw" in $$props) $$invalidate(16, fw = $$props.fw);
		if ("pull" in $$props) $$invalidate(17, pull = $$props.pull);
		if ("scale" in $$props) $$invalidate(18, scale = $$props.scale);
		if ("translateX" in $$props) $$invalidate(19, translateX = $$props.translateX);
		if ("translateY" in $$props) $$invalidate(20, translateY = $$props.translateY);
		if ("rotate" in $$props) $$invalidate(21, rotate = $$props.rotate);
		if ("flip" in $$props) $$invalidate(22, flip = $$props.flip);
		if ("spin" in $$props) $$invalidate(3, spin = $$props.spin);
		if ("pulse" in $$props) $$invalidate(4, pulse = $$props.pulse);
		if ("primaryColor" in $$props) $$invalidate(5, primaryColor = $$props.primaryColor);
		if ("secondaryColor" in $$props) $$invalidate(6, secondaryColor = $$props.secondaryColor);
		if ("primaryOpacity" in $$props) $$invalidate(7, primaryOpacity = $$props.primaryOpacity);
		if ("secondaryOpacity" in $$props) $$invalidate(8, secondaryOpacity = $$props.secondaryOpacity);
		if ("swapOpacity" in $$props) $$invalidate(9, swapOpacity = $$props.swapOpacity);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*icon*/ 16384) {
			$$invalidate(10, i = icon && icon.icon || [0, 0, "", [], ""]);
		}

		if ($$self.$$.dirty & /*style, size, pull, fw*/ 237568) {
			$$invalidate(11, s = getStyles(style, size, pull, fw));
		}

		if ($$self.$$.dirty & /*scale, translateX, translateY, rotate, flip*/ 8126464) {
			$$invalidate(12, transform = getTransform(scale, translateX, translateY, rotate, flip, 512));
		}
	};

	return [
		clazz,
		id,
		color,
		spin,
		pulse,
		primaryColor,
		secondaryColor,
		primaryOpacity,
		secondaryOpacity,
		swapOpacity,
		i,
		s,
		transform,
		style,
		icon,
		size,
		fw,
		pull,
		scale,
		translateX,
		translateY,
		rotate,
		flip
	];
}

class Fa extends internal.SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1cj2gr0-style")) add_css$1();

		internal.init(this, options, instance$2, create_fragment$2, internal.safe_not_equal, {
			class: 0,
			id: 1,
			style: 13,
			icon: 14,
			size: 15,
			color: 2,
			fw: 16,
			pull: 17,
			scale: 18,
			translateX: 19,
			translateY: 20,
			rotate: 21,
			flip: 22,
			spin: 3,
			pulse: 4,
			primaryColor: 5,
			secondaryColor: 6,
			primaryOpacity: 7,
			secondaryOpacity: 8,
			swapOpacity: 9
		});
	}
}

/* src\fa-layers.svelte generated by Svelte v3.16.7 */

function add_css() {
	var style = internal.element("style");
	style.id = "svelte-66hu08-style";
	style.textContent = ".svelte-fa-layers.svelte-66hu08{display:inline-block;position:relative}.svelte-fa-layers.svelte-66hu08 .svelte-fa{position:absolute;bottom:0;left:0;right:0;top:0;margin:auto;text-align:center}.svelte-fa-layers.svelte-66hu08 .svelte-fa-layers-text{position:absolute;top:50%;left:50%;transform:translate(-50%, -50%)}.svelte-fa-layers.svelte-66hu08 .svelte-fa-layers-text span{display:inline-block}";
	internal.append(document.head, style);
}

function create_fragment$1(ctx) {
	let span;
	let span_class_value;
	let current;
	const default_slot_template = /*$$slots*/ ctx[7].default;
	const default_slot = internal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	return {
		c() {
			span = internal.element("span");
			if (default_slot) default_slot.c();
			internal.attr(span, "id", /*id*/ ctx[1]);
			internal.attr(span, "class", span_class_value = "svelte-fa-layers " + /*clazz*/ ctx[0] + " svelte-66hu08");
			internal.attr(span, "style", /*s*/ ctx[2]);
		},
		m(target, anchor) {
			internal.insert(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot && default_slot.p && dirty & /*$$scope*/ 64) {
				default_slot.p(internal.get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[6], null), internal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null));
			}

			if (!current || dirty & /*id*/ 2) {
				internal.attr(span, "id", /*id*/ ctx[1]);
			}

			if (!current || dirty & /*clazz*/ 1 && span_class_value !== (span_class_value = "svelte-fa-layers " + /*clazz*/ ctx[0] + " svelte-66hu08")) {
				internal.attr(span, "class", span_class_value);
			}

			if (!current || dirty & /*s*/ 4) {
				internal.attr(span, "style", /*s*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;
			internal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			internal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) internal.detach(span);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let { class: clazz = "" } = $$props;
	let { id = "" } = $$props;
	let { style = "" } = $$props;
	let { size = "" } = $$props;
	let { pull = "" } = $$props;
	let s;
	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, clazz = $$props.class);
		if ("id" in $$props) $$invalidate(1, id = $$props.id);
		if ("style" in $$props) $$invalidate(3, style = $$props.style);
		if ("size" in $$props) $$invalidate(4, size = $$props.size);
		if ("pull" in $$props) $$invalidate(5, pull = $$props.pull);
		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*style, size, pull*/ 56) {
			$$invalidate(2, s = getStyles(style, size, pull, true));
		}
	};

	return [clazz, id, s, style, size, pull, $$scope, $$slots];
}

class Fa_layers extends internal.SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-66hu08-style")) add_css();

		internal.init(this, options, instance$1, create_fragment$1, internal.safe_not_equal, {
			class: 0,
			id: 1,
			style: 3,
			size: 4,
			pull: 5
		});
	}
}

/* src\fa-layers-text.svelte generated by Svelte v3.16.7 */

function create_fragment(ctx) {
	let span1;
	let span0;
	let span1_class_value;
	let current;
	const default_slot_template = /*$$slots*/ ctx[12].default;
	const default_slot = internal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	return {
		c() {
			span1 = internal.element("span");
			span0 = internal.element("span");
			if (default_slot) default_slot.c();
			internal.attr(span0, "style", /*s*/ ctx[2]);
			internal.attr(span1, "id", /*id*/ ctx[1]);
			internal.attr(span1, "class", span1_class_value = "svelte-fa-layers-text " + /*clazz*/ ctx[0]);
		},
		m(target, anchor) {
			internal.insert(target, span1, anchor);
			internal.append(span1, span0);

			if (default_slot) {
				default_slot.m(span0, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot && default_slot.p && dirty & /*$$scope*/ 2048) {
				default_slot.p(internal.get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[11], null), internal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null));
			}

			if (!current || dirty & /*s*/ 4) {
				internal.attr(span0, "style", /*s*/ ctx[2]);
			}

			if (!current || dirty & /*id*/ 2) {
				internal.attr(span1, "id", /*id*/ ctx[1]);
			}

			if (!current || dirty & /*clazz*/ 1 && span1_class_value !== (span1_class_value = "svelte-fa-layers-text " + /*clazz*/ ctx[0])) {
				internal.attr(span1, "class", span1_class_value);
			}
		},
		i(local) {
			if (current) return;
			internal.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			internal.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) internal.detach(span1);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { class: clazz = "" } = $$props;
	let { id = "" } = $$props;
	let { style = "" } = $$props;
	let { size = "" } = $$props;
	let { color = "" } = $$props;
	let { scale = 1 } = $$props;
	let { translateX = 0 } = $$props;
	let { translateY = 0 } = $$props;
	let { rotate = "" } = $$props;
	let { flip = false } = $$props;
	let s;
	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(0, clazz = $$props.class);
		if ("id" in $$props) $$invalidate(1, id = $$props.id);
		if ("style" in $$props) $$invalidate(3, style = $$props.style);
		if ("size" in $$props) $$invalidate(4, size = $$props.size);
		if ("color" in $$props) $$invalidate(5, color = $$props.color);
		if ("scale" in $$props) $$invalidate(6, scale = $$props.scale);
		if ("translateX" in $$props) $$invalidate(7, translateX = $$props.translateX);
		if ("translateY" in $$props) $$invalidate(8, translateY = $$props.translateY);
		if ("rotate" in $$props) $$invalidate(9, rotate = $$props.rotate);
		if ("flip" in $$props) $$invalidate(10, flip = $$props.flip);
		if ("$$scope" in $$props) $$invalidate(11, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*color, scale, translateX, translateY, rotate, flip, style, size*/ 2040) {
			$$invalidate(2, s = getStyles(
				joinCss([
					joinCss({
						color,
						display: "inline-block",
						height: "auto",
						transform: getTransform(scale, translateX, translateY, rotate, flip, undefined, "em", "deg")
					}),
					style
				]),
				size
			));
		}
	};

	return [
		clazz,
		id,
		s,
		style,
		size,
		color,
		scale,
		translateX,
		translateY,
		rotate,
		flip,
		$$scope,
		$$slots
	];
}

class Fa_layers_text extends internal.SvelteComponent {
	constructor(options) {
		super();

		internal.init(this, options, instance, create_fragment, internal.safe_not_equal, {
			class: 0,
			id: 1,
			style: 3,
			size: 4,
			color: 5,
			scale: 6,
			translateX: 7,
			translateY: 8,
			rotate: 9,
			flip: 10
		});
	}
}

exports.Fa = Fa;
exports.FaLayers = Fa_layers;
exports.FaLayersText = Fa_layers_text;
exports["default"] = Fa;
